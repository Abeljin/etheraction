<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Solidities on 精通以太坊</title>
    <link>https://ether.goall.top/solidity.html</link>
    <description>Recent content in Solidities on 精通以太坊</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>根据Apache 2.0 许可发布</copyright>
    <lastBuildDate>Sat, 20 Jan 2018 06:10:54 +0800</lastBuildDate>
    
	<atom:link href="https://ether.goall.top/solidity/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>简介</title>
      <link>https://ether.goall.top/solidity/doc/</link>
      <pubDate>Sat, 20 Jan 2018 06:10:54 +0800</pubDate>
      
      <guid>https://ether.goall.top/solidity/doc/</guid>
      <description>Solidity  Solidity 是面向智能合约的高级编程语言，它的设计受 C++、Python和JavaScript影响，旨在针对以太坊虚拟机(EVM)。
Solidity 是静态类型语言，支持继承，库和复杂的自定义类型等功能。
正如你见，它可用来创建投票，众筹，盲目拍卖，多签名钱包等等合同。
Note
现在，学习 Solidity 的最佳途径是用在线IDE Remix(可能需要加载一段时间完成准备，请耐心等待)。
 交易 下面文档已被社区志愿者翻译成几种语言，但是英文版可作为参考。
 Spanish Russian(已过时)  有用链接  以太坊官网 Solidity更新日志 用例看板 Solidity开源代码 以太坊 Stackexchange Gitter聊天  可用的 Solidity 集成  Remix 基于浏览器的IDE，含编译器和运行环境，无需服务端组件。
 IntelliJ IDEA 插件 集成到Intillij IDEA 的Solidity插件（支持所有的 JetBrains IDE）。
 Visual Studio 扩展 含 Solidity 编译器的 微软 Visual Studio 插件。
 SublimeText包- Solidity语法高亮 SublimeText编辑器中支持对 Solidty 语法高亮。
 Etheratom Atom 编辑器的 Solidity 插件，支持语法高亮，编译和一个运行时环境（后端节点与 VM 兼容）。</description>
    </item>
    
    <item>
      <title>智能合约介绍</title>
      <link>https://ether.goall.top/solidity/doc/introduction-to-smart-contracts.html</link>
      <pubDate>Sat, 20 Jan 2018 06:15:54 +0800</pubDate>
      
      <guid>https://ether.goall.top/solidity/doc/introduction-to-smart-contracts.html</guid>
      <description>一个简单的智能合约 如果你智能合约知之甚少，那从些简单的示例开始是必要的，更多细节后续再讲讲。
存储 pragma solidity ^0.4.0; contract SimpleStorage { uint storedData; function set(uint x) public { storedData = x; } function get() public constant returns (uint) { return storedData; } }  首行简洁的说明该源代码为Solidity 0.4.0版本编写或兼容新版本(直到但不包含0.5.0版本)。已确保合约不会与新版编译器有突异行为。被用关键字pragma原因是，一般编译指令是告知编译器该如何对待源代码（如：pragma once(编译一次)）。
一份Solidity所示合同就是一组代码(称为方法)合集和数据（称为状态），而数据位于以太坊区块链上特点地址上。行uint storedData;声明了一个类型为unit(无符号256位整数)的状态变量，名为storeData。你可将其想象为在数据库上的单个插槽，能通过调用管理数据库的代码来访问与修改。在以太坊下，它始终属于合约。这个示例中，方法set和get就能修改和获得此变量值。
为访问状态变量，无需借助这个在其他语言常见的前缀this.。
除允许任何人存储存储一个任何人都可访问的数字，而没有（可行的）方法类阻止你发布这个数字，这个合约做的还远远不够（基于以太坊建立基础设施）。当然，任何人只需再次用不同的值调用set就可覆盖这个数字。但是这个数字仍被存储在区块链的历史记录中。稍后我们来看看如何加强访问限制，以便只有你才能改变它。
提醒
所有标识符（合约名，函数名和变量名）都被限制为 ASCII 字符集。可以将 UTF-8 格式数据存储在字符串变量中。
 当心 Unicode 字符
看着很像（甚至一样）的 Unicode 字符是由不同的代码表示的，因此会被编码称不同的字节数组。
 子币示例 下面的合约将实现简单版加密货币。可以凭空创建币，但是只有创建这个合约的人才可这样做（实行不同的发行计划是微不足道的）。此外，任何人可以发送币到其他人而不需要使用用户名和密码注册 - 你仅需要一个以太坊密钥。
pragma solidity ^0.4.0; contract Coin { // The keyword &amp;quot;public&amp;quot; makes those variables // readable from outside.</description>
    </item>
    
    <item>
      <title>安装 Solidity</title>
      <link>https://ether.goall.top/solidity/doc/installing-solidity.html</link>
      <pubDate>Sat, 20 Jan 2018 06:16:54 +0800</pubDate>
      
      <guid>https://ether.goall.top/solidity/doc/installing-solidity.html</guid>
      <description>版本 不但发行版版本名遵循语意化版本原则，每晚自动构建版也遵循原则。尽管我们努力确保其正常，但有些非正式或破坏性变更会被包含，而使得每晚自动构建的版本也许无法正常使用。
推荐使用最新发行版，下面使用最新发行版进行安装说明。
Remix  推荐使用 Remix 来开发简单合约和快速学习 Solidity。
 无需安装任何东西，就可在线使用Reminx。如果你想离线使用，可按 https://github.com/ethereum/browser-solidity/tree/gh-pages 页面说明下载 zip 文件使用。
该页面有进一步详细说明如何安装 solidity 命令行编译器到你计算机上。如果你刚好要处理大型合约，或者需要更多的编译选项，那么选择使用命令行编译器 solc。
npm/ Node.js 使用 npm 安装 Solidity 编译器 solcjs 小菜一碟。solcjs 程序的功能比本页下面的所有选项都要少。在编译器 文档中，我们假定你所使用完整功能的编译器。 所以如果你是从 npm 安装 solcjs ，就此打住，直接跳到 solc-js 去了解。
Note
solcjs 是利用 Emscripten 从 C++ 版的 solc 跨平台编译为 JavaScript 的。可在 JavaScript 项目中使用 solcjs (同 Remix)。 具体介绍请查看 solcjs 代码库。
 npm install -g solc  Note
命令行工具名称为 solcjs
solcjs 的命令行选项同 solc 和一些工具(如 geth )是不兼容的。solcjs 是阉割版的 solc。</description>
    </item>
    
    <item>
      <title>Solidity 示例</title>
      <link>https://ether.goall.top/solidity/doc/solidity-by-example.html</link>
      <pubDate>Sat, 20 Jan 2018 06:30:54 +0800</pubDate>
      
      <guid>https://ether.goall.top/solidity/doc/solidity-by-example.html</guid>
      <description>投票 下面合约十分复杂，但也展示了 Solidity 的许多特性。它实现的是一个投票合约。当然，电子投票的主要问题是如何确保合法投票人权利和避免暗箱操作。这里，我们先不需处理这些问题，先至少能看到如何委托投票，能自动记票，同时还是完全透明的。
想法是为每次选票创建一个合约，提供投票项简称。合约创建者充当主席，给每个地址分配投票权。地址背后的人类，就可以自行投票或者将投票权委托给他信任的第三方。在投票截止时，winningProposal方法返回投票数最多的提案。
pragma solidity ^0.4.16; /// @title 代表团投票 contract Ballot { // 定义一个新的复合类型，会作为合约变量。 // 代表一名选民。 struct Voter { uint weight; // 累计的投票权重 bool voted; // 为 true 说明选名已投票 address delegate; // 选民委托给第三方 uint vote; // 投票提案项 } // 投票单个提案项 struct Proposal { bytes32 name; // 简称(32字节) uint voteCount; // 获票累计数 } address public chairperson; // 声明了一个状态变量来存储每个地址所代表的 `Voter` 信息。 mapping(address =&amp;gt; Voter) public voters; // 声明一个 `Proposal` 动态数组.</description>
    </item>
    
  </channel>
</rss>